

// select all the ressources to take into a container
// if not false, it will be taken
// can change who take it (here @flare)
// the bot will take ressource to it's max transport capacity


import onOff
import idBots


set store container1
set switch switch1
set message message1


// which bot to use
set botType @dagger
set botNb 3


// which ressources to take ?
// name in french, because it's easier for me to read it in game
set cuivre true        // @copper
set plomb true         // @lead
set silicium false      // @silicon
set graphite false      // @graphite
set charbon false       // @coal
set verreTremp false    // @metaglass
set titane false        // @titanium
set thorium false       // @thorium
set alliageSup false    // @surge-alloy
set mélangeExplo false  // @blast-compound
set pyratite false      // @pyratite
set tissuPhasé false    // @phase-fabric
set plastanium false    // @plastanium
set spore false         // @spore-pod
set sable false         // @sand
set ferraille false     // @scrap


// limite "enougth" at 100 (ps: max container is 300)
set storeStopQuantity 100
set storeMaxQuantity 300


// need to go closer if more bots, don't know why
if botNb == 1
    set radiusApproche 8
elif botNb <= 3
    set radiusApproche 7
else
    set radiusApproche 5 // max working radius: 8


set coreX null
set coreY null

set botOwnedNb 0


procId = idBots.genProcId()


#ref noStore
if store == null
    print "[yellow] not linked to store\n [white] default: [grey] container1 \n [white] you can change it at starting variables"
    end // will execute again: `set store container1`


// store position
sensor storeX store @x
sensor storeY store @y


if message == null
    end


set toTake null
set toTakeTimes 0
set toTakeId 0

set loopSearchingBots 0

// --- Prog Loop ---
#ref loop


// switch to turn off
isOn = onOff.isOn(switch)
if isOn != true
    msg.printAndWait("[yellow] process is turn off", message)
    end // to reset procId and botOwnedNb


op add loopSearchingBots loopSearchingBots 1
if loopSearchingBots > 24
    if botOwnedNb > 0
        set botOwnedNb 0
        set loopSearchingBots 0
    else
        print "[red] no bots of type: [grey]"
        print botType
        msg.printAndWait("[red] free to flag", message)

ubind botType

if @unit == null  // no bot of that type
    print "[yellow] no bots of type: [grey]"
    msg.printAndWait(botType, message)
    jump loop


sensor flag @unit @flag
isMyBot = idBots.isMyBotFlag(procId, flag)
if isMyBot != true
    if botOwnedNb < botNb  // need one ?
        // msg.printAndWait("[yellow] searching fot bots", message)
        if flag == 0 // is free
            // msg.printAndWait("[green] found !", message)
            op add botOwnedNb botOwnedNb 1  // botOwnedNb += 1
            idBots.flagBot(procId, botOwnedNb)
            jump okBot
        // print "flagged ? "
        // msg.printAndWait(flag, message)
    jump loop


#ref okBot

set loopSearchingBots 0

// get core position
#ref getCorePos
// require to have a @unite
if coreX == null
    msg.printAndWait("looking for core, this is done once", message)
    ulocate building core false @copper coreX coreY coreFound core
    if coreFound == false
        msg.printAndWait("[red] core not found, searching again", message)
        msg.printAndWait(core, message)
        msg.printAndWait(coreFound, message)
        jump getCorePos
    msg.printAndWait("[green] core found", message)


// does we need to know what to take ?
if toTakeTimes > 0
    print "to Take: [grey]"
    print toTake
    print " [white]"
    print toTakeTimes
    printflush message
    op sub toTakeTimes toTakeTimes 1
    jump endToTake


msg.printAndWait("[yellow] process toTake", message)

set loopingToTake 0

#ref startToTake

op add loopingToTake loopingToTake 1

// need to change what to take
// op add toTakeId toTakeId 1
// if toTakeId == 1
//     if cuivre == true
//         // need it ?
//         sensor stored store @copper
//         if stored < storeStopQuantity
//             set toTake @copper
//             jump setTimesToTake
//     op add toTakeId toTakeId 1

// if toTakeId == 2
//     if plomb == true
//         // need it ?
//         sensor stored store @lead
//         if stored < storeStopQuantity
//             set toTake @lead
//             jump setTimesToTake
//     op add toTakeId toTakeId 1


op add toTakeId toTakeId 1

// if toTakeId == 2
//     if plomb == true
//         // need it ?
//         sensor stored store @lead
//         if stored < storeStopQuantity
//             set toTake @lead
//             jump setTimesToTake
//     op add toTakeId toTakeId 1


// a marco is a brutal copy/past (no scope unlike function)
macro processToTake(id, ressource, ressourceType)
    if toTakeId == id
        op add toTakeId toTakeId 1  // will pass to next ressource even if this one is still needed
        if ressource == true
            sensor stored store ressourceType
            if stored < storeStopQuantity
                set toTake ressourceType
                jump setTimesToTake

processToTake(1, cuivre, @copper)
processToTake(2, plomb, @lead)


// we have done alls the ifs, back to the start
set toTakeId 0
// if it repeat
// will need a check stuck (bot full that can't unload)
// or lower the bot owned for a shot time ?
if loopingToTake > 5
    msg.printAndWait("[red] nothing toTake, is all ressource set to false or store is full ?", message)

jump startToTake

// we will conserve this calculation X times
#ref setTimesToTake
set toTakeTimes 30

#ref endToTake


// sensor on bot load
sensor payload @unit @totalItems
// sensor loadType @unit @payloadType  // sadly, this does not work, always return null


// to check if content a specific ressource:
// sensor copperTranported @unit @copper
// copperTranported will be equal to payload if unit tranport it, else null
// need to check max ressource to know if we can unload it
// sensor stored store loadType


if payload > 0 // unload in store
    ucontrol approach storeX storeY radiusApproche null null
    ucontrol itemDrop store 800 null null null

else // take some ressources
    ucontrol approach coreX coreY radiusApproche null null
    sensor coreStored core toTake
    if coreStored > 60 // take it
        ucontrol itemTake core toTake 800 null null
    else
        print "[yellow] not enouth of "
        print toTake
        msg.printAndWait(" in base, will take something else", message)
        jump startToTake // <--- will redo what need to be taken

jump loop
