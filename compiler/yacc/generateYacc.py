

from typing import Callable
from pathlib import PurePath
import os


class GenerateContext:
    p_fun = {}
    p_imports = {}


context = GenerateContext()


# a decorator to get grammar function (ak: p_fun)
# use it to declare a p_function
def grammar(p_fun: Callable):
    p_name = p_fun.__name__
    if p_name in context.p_fun:
        raise Exception("function {} is defined more than once".format(p_name))
    context.p_fun[p_name] = p_fun
    p_import = p_fun.__module__
    if p_import not in context.p_imports:
        context.p_imports[p_import] = True
    return p_fun


fileInfo = '''
# This file is automatically generated. Do not edit.'''


lexTokenImport = '''
from typing import Callable


from ply import yacc
# Required to build parser
from compiler.lex import tokens  # noqa
'''


decoratorFunction = '''
def linkP(funToCall: Callable):
    def deco(emptyFun):
        def called(p):
            funToCall(p)
        called.__doc__ = funToCall.__doc__
        called.__name__ = 'p_' + funToCall.__name__
        return called
        return funToCall  # does not work, why ?
    return deco
'''


def getGeneratedContent():
    c = []
    c.append(fileInfo)
    c.append('')
    c.append(lexTokenImport)
    c.append('')

    for p_import in list(context.p_imports.keys()):
        c.append('import {}'.format(p_import))

    c.append('')
    # c.append(decoratorFunction)
    # c.append('')

    funList = list(context.p_fun.values())
    # funList.reverse()
    for p_fun in funList:
        fun_name = p_fun.__name__
        fun_doc = p_fun.__doc__
        fun_module = p_fun.__module__
        # c.append('@linkP({fun_module}.{fun_name})'.format(fun_module=fun_module, fun_name=fun_name))
        # c.append('def p_{fun_name}(p): pass'.format(fun_name=fun_name))
        c.append('def p_{fun_name}(p):'.format(fun_name=fun_name))
        c.append("    '''{fun_doc}'''".format(fun_doc=fun_doc))
        c.append('    {fun_module}.{fun_name}(p)'.format(fun_module=fun_module, fun_name=fun_name))
        c.append('')

    c.append('\n')
    c.append('parser = yacc.yacc()')

    strContent = '\n'.join(c) + '\n'
    return strContent


# confused with open mode w, w+ ? here the link:
# https://stackoverflow.com/questions/1466000/difference-between-modes-a-a-w-w-and-r-in-built-in-open-function/30566011#30566011
def generateYaccFunctions():
    generatedContent = getGeneratedContent()
    generatedFile = PurePath(os.path.dirname(__file__), 'p_functionYacc.py')
    with open(generatedFile, 'w') as fd:
        fd.write(generatedContent)
