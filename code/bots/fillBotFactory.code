

// select all the ressources to take into a container
// if not false, it will be taken
// can change who take it (here @flare)
// the bot will take ressource to it's max transport capacity


import onOff
import idBots
import msg


set appro container1

set switch switch1
set message message1
set ressource @silicium
sensor helper copyPast @silicon
set copyHelper toRessource

// which bot to use
ubind @dagger  // let player choose with bot image the bind
set botNb 3

set radiusApproche 6 // max working radius: 8


set coreX null
set coreY null


if appro != null
    print "[green] appro not null, will replace core to take ressource from"
    msg.printAndWait(appro, message)
    // appro position, default to core if null
    sensor coreX appro @x
    sensor coreY appro @y
    set core appro


set botOwnedNb 0

// procId = idBots.genProcId()


set loopSearchingBots 0

if @unit == null  // no bot of that type
    print "[yellow] no bots of the choosen type, \n"
    print "you can pick another kind of bot in the instruction 'ubind' at the begining of the programme"
    msg.printAndWait("", message)
    end


// get core position
#ref getCorePos
// require to have a @unite
if coreX == null
    msg.printAndWait("looking for core, this is done once", message)
    ulocate building core false @copper coreX coreY coreFound core
    if coreFound == false
        msg.printAndWait("[red] core not found, searching again", message)
        msg.printAndWait(core, message)
        msg.printAndWait(coreFound, message)
        jump getCorePos
    msg.printAndWait("[green] core found", message)


sensor botType @unit @type // get botType

if botNb > 6
    msg.printAndWait("[red] can't take more than 6 bots\n change parameter 'botNb' to fix it", message)
    end

// variable content is keep after end instruction, memory not free
for ownedBot in [bot1, bot2, bot3, bot4, bot5, bot6]
    set ownedBot null

set currentOwnedId 1

set factoLinkIndice 0


set ressourceGroundFact false

if ressource == @lead
    set ressourceGroundFact true
elif ressource == @silicon
    set ressourceGroundFact true


// --- Prog Loop ---
#ref loop

// switch to turn off
isOn = onOff.isOn(switch)
if isOn != true
    msg.printAndWait("[yellow] process is turn off", message)
    end // to reset procId and botOwnedNb


op add loopSearchingBots loopSearchingBots 1
if loopSearchingBots > 24
    print "[red] no bots of type: [grey]"
    print botType
    msg.printAndWait("[red] free", message)


// take bot if need more, else loop thought owned bots
if botOwnedNb < botNb // need one ?
    print "[white] need some more bots"
    printflush message
    ubind botType  // try to catch one
    if @unit == null // we no longuer have that kind of bots
        print "[yellow] no bots of the choosen type anymore, \n"
        print "you can pick another kind of bot in the instruction 'ubind' at the begining of the programme"
        msg.printAndWait("", message)
        jump loop
    // have an owner ?
    sensor owner @unit @controller
    sensor typeOfOwner owner @type
    if typeOfOwner == botType  // is free
        // ucontrol flag procId null null null null  // tag it
        print "[green] free bot found !"
        printflush message
        op add botOwnedNb botOwnedNb 1  // botOwnedNb += 1
        // save owned bot
        for ownedBot in [bot1, bot2, bot3, bot4, bot5, bot6]
            if ownedBot == null
                set ownedBot @unit
                jump endBotSave


#ref endBotSave

// take one owned bot at a time
for ownedBot, ownedId in [(bot1, 1), (bot2, 2), (bot3, 3), (bot4, 4), (bot5, 5), (bot6, 6)]
    if currentOwnedId == ownedId // the bot to process
        // set @unit ownedBot // not working
        ubind ownedBot
        jump okBot

#ref okBot

if currentOwnedId > botOwnedNb
    set currentOwnedId 1
    jump loop // to take opportunity to owne another bot

op add currentOwnedId currentOwnedId 1

set loopSearchingBots 0

// sensor isNotDead @unit @dead // don't realy know what it return
if isDead == true
    msg.printAndWait("unit is dead, [yellow] Reset", message)
    end

if @unit == null
    msg.printAndWait("unit is null, [yellow] Reset", message)
    end


#ref linkingFacto
// link stuff
set passLink false
getlink facto factoLinkIndice
if facto == null // end link list
    set factoLinkIndice 0
    jump linkingFacto

// check facto type
sensor type facto @type
if type == @message
    set passLink true
elif type == @ground-factory
    msg.printAndWait("is ground fact", message)
    if ressourceGroundFact == true
        msg.printAndWait("ressource ok for a ground factory", message)
elif type == @air-factory
    msg.printAndWait("is air fact", message)

op add factoLinkIndice factoLinkIndice 1

if passLink == true
    jump linkingFacto


sensor factoX facto @x
sensor factoY facto @y
sensor maxCapacity facto @itemCapacity
sensor currentCapacity facto ressource

if currentCapacity == maxCapacity
    msg.printAndWait("is full", message)


// sensor on bot load
sensor payload @unit @totalItems


// to check if content a specific ressource:
// sensor copperTranported @unit @copper
// copperTranported will be equal to payload if unit tranport it, else null
// need to check max ressource to know if we can unload it
// sensor stored store loadType


if payload > 0 // unload in store
    sensor actuallyTranportingRessource @unit ressource
    if actuallyTranportingRessource != payload // not transporting the desired ressource
        ucontrol payDrop 0 0 0 0 0
    ucontrol approach factoX factoY radiusApproche null null
    ucontrol itemDrop store 800 null null null

else // take some ressources
    ucontrol approach coreX coreY radiusApproche null null
    sensor coreStored core toTake
    if coreStored > 60 // take it
        ucontrol itemTake core toTake 800 null null
    else
        print "[yellow] not enouth of "
        print toTake
        msg.printAndWait(" in base, will take something else", message)
        jump startToTake // <--- will redo what need to be taken

jump loop
